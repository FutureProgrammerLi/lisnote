import{s as p,o as a,c as t,t as l,I as h,a3 as n}from"./chunks/framework.C6jertZK.js";const k={__name:"Counter",setup(e){const s=p(0);function i(){s.value++}return(d,E)=>(a(),t("button",{onClick:i,class:"text-2xl font-sants bg-purple-700 text-white px-2 py-1"}," You clicked "+l(s.value)+" times ",1))}},r=n('<h1 id="两个react" tabindex="-1">两个React <a class="header-anchor" href="#两个react" aria-label="Permalink to &quot;两个React&quot;">​</a></h1><blockquote><p><a href="https://overreacted.io/the-two-reacts/" target="_blank" rel="noreferrer">https://overreacted.io/the-two-reacts/</a><br> 作者:Dan Abramov<br> 是一月的Blog了,2024.5月的React Conference上,Dan也有根据这篇文章介绍了相似概念.<br> 就,相当于Conference的一篇手稿吧.<br> 12:38 - 1:37</p></blockquote><p>假设我需要在你屏幕上显示一些东西,无论是一个网页,一个应用,或者是一个从应用商城上下载来的APP,这个过程中,必然至少含有两个设备:<strong>你的设备,还有我的设备</strong>.<br> 过程的开始,是从我设备上的代码及数据出发的.比如说,我先要在我电脑上写出一篇文章的内容.而如果你能看到我写的这些内容,说明我电脑上的东西,已经通过某些过程,转化成HTML,Javascript,从而展示到你的设备之上了.<br> 什么?你说这跟React有什么关系?如果你不是开发者,你或许不需要了解这个过程.但看到这篇文章的你,大概是React开发者吧.React的编程范式是基于构建UI的,它允许开发者将内容分解开来(一篇博客,一个注册表格,或是一整个应用),由一个个独立的组件,像搭乐高积木一样,一块一块组合起来.你应该知道并很喜欢组件这个概念了吧.如果不是很了解可以去<a href="http://react.dev" target="_blank" rel="noreferrer">react.dev</a>官网看看.<br> 组件就是代码,而这些代码需要在某个地方运行起来它才能发挥作用.等等--它要在哪台电脑上运行呢?你的?还是我的呢?<br> 试试说明一下到底需要在哪台电脑上运行这些代码吧.</p><hr><p>如果说这些组件代码要在你的电脑上运行.<br> 这是一个展示交互的,简单得不得了的计数按钮.试试点几次?</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div>',6),o=n(`<p>假如说要渲染这个组件的JS代码已经加载好了,那你每次按这个按钮,计数器就会加一.其中一点延迟没有,不需要等待服务器回应,也不需要从服务器中获取额外的数据.<br> 按这个道理说,这个组件的代码是在你的电脑上运行的:</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dark:color-white rounded-lg bg-purple-700 px-2 py-1 font-sans font-semibold text-white focus:ring active:bg-purple-600&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        &gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      You clicked me {count} times</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这里的<code>count</code>是一个客户端的状态(client state)--是你电脑内存里的部分,你每按一次它,这个状态就会更新一次.<strong>我不知道你会按它多少次</strong>,我也就不可能在我的电脑上,预测并为这个状态作出所有可能的输出(predict and prepare).在我电脑上最敢肯定的一件事就是,<strong>这个计数器最开始是从0开始的.</strong> 我把它转化为HTML之后,它要怎么变,就<em>归你的电脑所管</em>了.</p><p>你或许会说,就这也用得着在我的电脑上运行?不直接在服务器上运行?为什么不在我每次按按钮的时候,询问服务器接下来要怎样渲染我的组件?在客户端JS框架出生之前不就是这么做的吗?</p><p>是的,确实如此:如果用户只想有一点点延迟,只感觉到一点点卡的时候确实可以这么做<br> --比如说点到一个超链接.用户知道要在应用内跳转的时候,他们早就料到了会有一点点白屏时间. 不过,不是所有操作用户都有心理准备的--你不能让用户在你应用中随便干点什么都卡.</p><p>像网页下拉,切换标签,打字之后显示到对应框,点击按钮,切换卡片,悬停菜单,图标拖拽等等,用户的操作可太多了.<strong>如果你的网页干点这些简单到不得了的东西都让用户感觉到卡,那就,就就就,完犊子了.</strong> 当然这不是强制的,如果你作为开发者能接受完犊子的话,只是用户很可能不会再用你的网页而已啦?<br><strong>用户希望每个动作都是有反馈的.</strong><br> 比如搭电梯,你知道按了楼层按钮不会立马到达对应楼层,但你按了按钮后,按钮的高亮,是作为最基本的反馈,表明你已经向电梯说明了你要去第几层.推门把手时也是,门没锁的话,你扭动推开后门不立即打开,你肯定就怀疑门把手是不是坏了,而不是我这个动作会导致门把手&quot;有延迟&quot;(这个想法还挺搞笑的哈哈哈哈).</p><p><strong>作为开发者,在构建网页时,要尽可能快地响应用户的操作.(低延迟,&quot;零&quot;网络往返感知)</strong></p>`,7),u=JSON.parse('{"title":"两个React","description":"","frontmatter":{},"headers":[],"relativePath":"react/DansBlogs/The-Two-Reacts.md","filePath":"react/DansBlogs/The-Two-Reacts.md"}'),c={name:"react/DansBlogs/The-Two-Reacts.md"},y=Object.assign(c,{setup(e){return(s,i)=>(a(),t("div",null,[r,h(k),o]))}});export{u as __pageData,y as default};
